%link{rel: :stylesheet, type: :'text/css', href: 'dense35.css', media: 'screen'}
.charsheet
  .sheet-grid
    -# HEADER
    .sheet-header
      .sheet-header-row1
        .sheet-label Name:
        .sheet-ui
          %input{type: 'text', name: 'attr_charname'}
        .sheet-label Race:
        .sheet-ui
          %input{type: 'text', name: 'attr_race'}
        .sheet-label Class:
        .sheet-ui
          %input{type: 'text', name: 'attr_class'}
        .sheet-label Religion:
        .sheet-ui
          %input{type: 'text', name: 'attr_religion'}
      .sheet-header-row2
        .sheet-label Ht:
        .sheet-ui
          %input{type: 'text', name: 'attr_height'}
        .sheet-label Wt:
        .sheet-ui
          %input{type: 'text', name: 'attr_weight'}
        .sheet-label Sex:
        .sheet-ui
          %input{type: 'text', name: 'attr_sex'}
        .sheet-label Age:
        .sheet-ui
          %input{type: 'text', name: 'attr_age'}
        .sheet-label Alignment:
        .sheet-ui
          %input{type: 'text', name: 'attr_alignment'}
        .sheet-label Level:
        .sheet-ui
          %input{type: 'text', name: 'attr_level'}
        .sheet-label XP:
        .sheet-ui
          %input{type: 'text', name: 'attr_xp'}
        .sheet-label Needed:
        .sheet-ui
          %input{type: 'text', name: 'attr_needed'}
        .sheet-label Speed:
        .sheet-ui
          %input{type: 'text', name: 'attr_speed'}
      .sheet-header-row3
        .sheet-label Region:
        .sheet-ui
          %input{type: 'text', name: 'attr_region'}
        .sheet-label Eyes:
        .sheet-ui
          %input{type: 'text', name: 'attr_eyes'}
        .sheet-label Hair:
        .sheet-ui
          %input{type: 'text', name: 'attr_hair'}
        .sheet-label Size:
        .sheet-ui
          %select{name: 'attr_size'}
            %option Fine
            %option Diminutive
            %option Tiny
            %option Small
            %option Medium
            %option Large
            %option Huge
            %option Gargantuan
            %option Colossal
        .sheet-label Appearance:
        .sheet-ui
          %input{type: 'text', name: 'attr_appearance'}

    -# ABILITY SCORES
    .sheet-ability-scores
      .sheet-ability-scores-top
        .blank
        .sheet-label.sheet-ability-scores-header Score
        .sheet-label.sheet-ability-scores-header Mod
        .sheet-label.sheet-ability-scores-header Temp
        .sheet-label.sheet-ability-scores-header Mod
      .sheet-ability-scores-table
        - %w(str dex con int wis cha).each do |val|
          .sheet-label= val.upcase
          .sheet-ui
            %input{type: 'text', name: "attr_#{val}"}
          .sheet-ui
            %input{type: 'text', name: "attr_#{val}Mod", readonly: true}
          .sheet-ui
            %input{type: 'text', name: "attr_#{val}Temp"}
          .sheet-ui
            %input{type: 'text', name: "attr_#{val}TempMod", readonly: true}

    -# SAVES & AC
    .sheet-saves-ac
      .sheet-saves-ac-sec1
        .sheet-label SAVE
        - %w(Total Base Stat Magic).each do |val|
          .sheet-label.sheet-table-subheader= val
        .sheet-label.sheet-table-subheader.sheet-saves-ac-misc-merge Misc
        - %w(FORT REF WILL).each do |val|
          .sheet-label= val
          .sheet-ui
            %input{type: 'text', name: "attr_save#{val}Total"}
          .sheet-ui
            %input{type: 'text', name: "attr_save#{val}Base"}
          .sheet-ui
            %input{type: 'text', name: "attr_save#{val}Stat"}
          .sheet-ui
            %input{type: 'text', name: "attr_save#{val}Magic"}
          .sheet-ui
            %input{type: 'text', name: "attr_save#{val}Misc"}
          .sheet-ui.sheet-hideleft
            %input{type: 'text', name: "attr_save#{val}MiscExplanation", placeholder: '...'}
      .sheet-saves-ac-sec2
        .sheet-label.sheet-table-subheader  Max HP:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_maxHitPoints"}
        .sheet-label.sheet-table-subheader  Current HP:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_currentHitPoints"}
        .sheet-label.sheet-table-subheader Initiative:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_initiative"}
      .sheet-saves-ac-sec3
        .sheet-label.sheet-italics
        .sheet-label.sheet-italics.sheet-hideleft Total
        - %w(Armor Shield DEX Size Nat Deflect Misc).each do |val|
          .sheet-label.sheet-hideleft.sheet-italics=val
      .sheet-saves-ac-sec4
        .sheet-label AC
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_acTotal"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_acBase", readonly: true, value: 10}
        - %w(Armor Shield Dex Size Nat Deflect Misc).each do |val|
          .sheet-label.sheet-hideleft +
          .sheet-ui.sheet-hideleft
            %input{type: 'text', name: "attr_ac#{val}"}
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_acMiscExplain", placeholder: '...'}

    -# ATTACK BONUSES
    .sheet-attack-bonus
      .sheet-attack-bonus-sec1
        .sheet-label BASE ATTACK BONUS:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_baseAttackBonus"}
      .sheet-attack-bonus-sec2
        .sheet-label
        .sheet-label.sheet-hideleft.sheet-italics Total
        .sheet-label.sheet-hideleft.sheet-italics
        .sheet-label.sheet-hideleft.sheet-italics Base
        .sheet-label.sheet-hideleft.sheet-italics
        .sheet-label.sheet-hideleft.sheet-italics Stat
        .sheet-label.sheet-hideleft.sheet-italics
        .sheet-label.sheet-hideleft.sheet-italics Size
        .sheet-label.sheet-hideleft.sheet-italics
        .sheet-label.sheet-hideleft.sheet-italics Misc
        .sheet-label.sheet-hideleft
        .sheet-label.sheet-attack-melee &#9876; Melee:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeTotal"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeBase"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeStatBonus", placeholder: 'STR'}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeSize"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeMisc"}
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_meleeExplanation", placeholder: '...'}
        .sheet-label.sheet-attack-range &#9732; Range:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeTotal"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeBase"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeStatBonus", placeholder: 'DEX'}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeSize"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeMisc"}
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_rangeExplanation", placeholder: '...'}
        .sheet-label.sheet-attack-grapple Grapple:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleTotal"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleBase"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleStatBonus", placeholder: 'STR'}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleSize"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleMisc"}
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_grappleExplanation", placeholder: '...'}
      .sheet-attack-bonus-sec3
        .sheet-label Touch AC:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_touchAC", placeholder: 'No Armor/Shield/Nat'}
        .sheet-label Flat Footed AC:
        .sheet-ui.sheet-hideleft
          %input{type: 'text', name: "attr_flatFootedAC", placeholder: 'No Dex/Dodge'}

    -# WEAPONS
    .sheet-weapons
      .sheet-label.sheet-table-header.sheet-weapons-header Weapons
      .sheet-label.sheet-table-header.sheet-tohit-header ToHit
      .sheet-label.sheet-table-header.sheet-damage-header Dmg
      .sheet-label.sheet-table-header.sheet-crit-header Crit
      .sheet-label.sheet-table-header.sheet-range-header Range
      .sheet-label.sheet-table-header.sheet-wpnsize-header Size
      .sheet-label.sheet-table-header.sheet-wpnwt-header Wt
      .sheet-label.sheet-table-header.sheet-wpnspecial-header Special Abilities
      - (1..7).each do |i|
        - %w(weapons toHit damage crit range wpnSize wpnWt wpnSpecial).each do |val|
          .sheet-ui{class: "sheet-#{val}#{i}"}
            %input{type: 'text', name: "attr_#{val}#{i}"}

    -# ARMOR
    .sheet-armor
      .sheet-label.sheet-table-header.sheet-armor-header Armor/Shield/Item
      .sheet-label.sheet-table-header.sheet-bonus-header Bonus
      .sheet-label.sheet-table-header.sheet-maxdex-header Max Dex
      .sheet-label.sheet-table-header.sheet-penalty-header &#10004;Penalty
      .sheet-label.sheet-table-header.sheet-spell-header Spell&#9785;
      .sheet-label.sheet-table-header.sheet-armorwt-header Wt
      .sheet-label.sheet-table-header.sheet-armorspecial-header Special Abilities
      - (1..5).each do |i|
        - %w(armor bonus maxdex penalty spell armorwt armorspecial).each do |val|
          .sheet-ui{class: "sheet-#{val}#{i}"}
            %input{type: 'text', name: "attr_#{val}#{i}"}

    -# TRAITS & ABILITIES
    .sheet-traits-abilities
      .sheet-label.sheet-table-header.sheet-racial-traits-header Racial Traits
      - (1..8).each do |i|
        .sheet-ui{class: "sheet-racial-traits#{i}"}
          %input{type: 'text', name: "attr_racialTraits#{i}"}
      .sheet-label.sheet-table-header.sheet-languages-header Languages
      - (1..8).each do |i|
        .sheet-ui{class: "sheet-languages#{i}"}
          %input{type: 'text', name: "attr_languages#{i}"}
      .sheet-label.sheet-table-header.sheet-class-abilities-header Class Abilities
      - (1..17).each do |i|
        .sheet-ui{class: "sheet-class-abilities#{i}"}
          %input{type: 'text', name: "attr_classAbilities#{i}"}
      .sheet-label.sheet-table-header.sheet-feats-header Feats
      - (1..17).each do |i|
        .sheet-ui{class: "sheet-feats#{i}"}
          %input{type: 'text', name: "attr_feats#{i}"}

    -# EQUIPMENT
    .sheet-equipment
      .sheet-label.sheet-table-header.sheet-equipment-header EQUIPMENT
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader1 In Backpack
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader2 Wt
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader3 Worn
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader4 Wt
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader5 Magical Items
      .sheet-label.sheet-table-subheader.sheet-equipment-subheader6 Wt
      - (1..28).each do |i|
        .sheet-ui{class: "sheet-backpack#{i}"}
          %input{type: 'text', name: "attr_backpack#{i}"}
      - (1..28).each do |i|
        .sheet-ui{class: "sheet-backpack-wt#{i}"}
          %input{type: 'text', name: "attr_backpackWt#{i}"}
      - (1..28).each do |i|
        .sheet-ui{class: "sheet-worn#{i}"}
          %input{type: 'text', name: "attr_worn#{i}"}
      - (1..28).each do |i|
        .sheet-ui{class: "sheet-worn-wt#{i}"}
          %input{type: 'text', name: "attr_wornWt#{i}"}
      - item_slots = %w(head face throat shldrs torso body arms hands ring1 ring2 waist feet)
      - item_slots.each do |val|
        .sheet-label-magic-item= val[0].upcase + val[1..-1] + ':'
      - ((item_slots.count + 1)..28).each do |i|
        .sheet-label-magic-item
          %input{type: 'text', name: "attr_magicItemSlot#{i}", placeholder: " ..."}
      - (1..28).each do |i|
        .sheet-ui.sheet-magic-item-description{class: "sheet-magic-item#{i}"}
          %input{type: 'text', name: "attr_magicItem#{i}"}
      - (1..28).each do |i|
        .sheet-ui{class: "sheet-magic-item-wt#{i}"}
          %input{type: 'text', name: "attr_magicItemWt#{i}"}

    -# WEIGHT / LOADING
    .sheet-carry-weight
      .sheet-label-small Total Weight:
      .sheet-ui{class: "sheet-total-weight sheet-hideleft"}
        %input{type: 'text', name: "attr_totalWeight"}
      .sheet-label-small.sheet-hideleft Light (1/3):
      .sheet-ui{class: "sheet-weight-light sheet-hideleft"}
        %input{type: 'text', name: "attr_weightLight"}
      .sheet-label-small.sheet-hideleft Medium (2/3):
      .sheet-ui{class: "sheet-weight-medium sheet-hideleft"}
        %input{type: 'text', name: "attr_weightMedium"}
      .sheet-label-small.sheet-hideleft Heavy:
      .sheet-ui{class: "sheet-weight-heavy sheet-hideleft"}
        %input{type: 'text', name: "attr_weightHeavy"}
      .sheet-label-small.sheet-hideleft Lift (2x):
      .sheet-ui{class: "sheet-weight-lift sheet-hideleft"}
        %input{type: 'text', name: "attr_weightLift"}
      .sheet-label-small.sheet-hideleft Drag (5x):
      .sheet-ui{class: "sheet-weight-drag sheet-hideleft"}
        %input{type: 'text', name: "attr_weightDrag"}

    -# SKILLS
    .sheet-skills
      .sheet-label.sheet-table-header.sheet-skills-header SKILLS
      .sheet-label-small.sheet-skills-explain Mod = Stat + Ranks + Misc
      -skills = { 'Appraise' => [0, 'INT'], 'Autohypnosis' => [1, 'WIS'], 'Balance' => [0, 'DEX'], 'Bluff' => [0, 'CHA'], 'Climb' => [0, 'STR'], 'Concentration' => [0, 'CON'], 'CraftFillIn1' => [0, 'INT'], 'CraftFillIn2' => [0, 'INT'], 'CraftFillIn3' => [0, 'INT'], 'Decipher Script' => [1, 'INT'], 'Diplomacy' => [0, 'CHA'], 'Disable Device' => [1, 'INT'], 'Disguise' => [0, 'CHA'], 'Escape Artist' => [0, 'DEX'], 'Forgery' => [0, 'INT'], 'Gather Info' => [0, 'CHA'], 'Handle Animal' => [1, 'CHA'], 'Heal' => [0, 'WIS'], 'Hide' => [0, 'DEX'], 'Intimidate' => [0, 'CHA'], 'Jump' => [0, 'STR'], 'KnowledgeFillIn1' => [1, 'INT'], 'KnowledgeFillIn2' => [1, 'INT'], 'KnowledgeFillIn3' => [1, 'INT'], 'KnowledgeFillIn4' => [1, 'INT'], 'KnowledgeFillIn5' => [1, 'INT'], 'Listen' => [0, 'WIS'], 'Move Silently' => [0, 'DEX'], 'Open Lock' => [1, 'DEX'], 'PerformFillIn1' => [0, 'CHA'], 'PerformFillIn2' => [0, 'CHA'], 'PerformFillIn3' => [0, 'CHA'], 'ProfessionFillIn1' => [1, 'WIS'], 'ProfessionFillIn2' => [1, 'WIS'], 'PsiCraft' => [1, 'INT'], 'Ride' => [0, 'DEX'], 'Search' => [0, 'INT'], 'Sense Motive' => [0, 'WIS'], 'Sleight Of Hand' => [1, 'DEX'], 'Speak Language' => [1, 'INT'], 'SpellCraft' => [1, 'INT'], 'Spot' => [0, 'WIS'], 'Survival' => [0, 'WIS'], 'Swim' => [0, 'STR'], 'Tumble' => [1, 'DEX'], 'Use Magic Device' => [1, 'CHA'], 'Use Psionic Device' => [1, 'CHA'], 'Use Rope' => [0, 'DEX'], }
      - skills.each do |k, v|
        - if k =~ /FillIn\d+/
          .sheet-label.sheet-label-skills.sheet-split-skill= k.gsub(/FillIn\d+/, '') + (v[0].zero? ? ' &#10041;' : '')
          .sheet-ui.sheet-split-skill-explanation.sheet-hideleft
            %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}SplitSkillExplanation", placeholder: '...'}
        - else
          .sheet-label.sheet-label-skills.sheet-merged-skill= k.gsub(/FillIn\d+/, '') + (v[0].zero? ? ' &#10041;' : '')
        .sheet-ui.sheet-skill-total
          %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}Total"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-skill-statmod.sheet-hideleft
          %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}Statmod", placeholder: v[1]}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-skill-ranks.sheet-hideleft
          %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}Ranks"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-skill-miscmod.sheet-hideleft
          %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}Miscmod"}
        .sheet-ui.sheet-skill-misc-explanation.sheet-hideleft
          %input{type: 'text', name: "attr_#{k.downcase.tr(' ', '')}MiscExplanation", placeholder: '...'}
      - 3.times do |i|
        .sheet-ui.sheet-label-sheet-skills.sheet-merged-skill
          %input{type: 'text', name: "attr_skillMisc#{i}Name", placeholder: ' ...'}
        .sheet-ui.sheet-skill-total
          %input{type: 'text', name: "attr_skillMisc#{i}Total"}
        .sheet-label.sheet-hideleft =
        .sheet-ui.sheet-skill-statmod.sheet-hideleft
          %input{type: 'text', name: "attr_skillMisc#{i}Statmod"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-skill-ranks.sheet-hideleft
          %input{type: 'text', name: "attr_skillMisc#{i}Ranks"}
        .sheet-label.sheet-hideleft +
        .sheet-ui.sheet-skill-miscmod.sheet-hideleft
          %input{type: 'text', name: "attr_skillMisc#{i}Miscmod"}
        .sheet-ui.sheet-skill-misc-explanation.sheet-hideleft
          %input{type: 'text', name: "attr_skillMisc#{i}MiscExplanation"}
      - 12.times do |i|
        .sheet-ui.sheet-skill-miscline
          %input{type: 'text', name: "attr_miscline#{i}"}
      .sheet-skill-money
        .sheet-label.sheet-skill-money-details PP:
        .sheet-ui.sheet-skill-money-details.sheet-hideleft
          %input{type: 'text', name: "attr_platinumPieces"}
        .sheet-label.sheet-skill-money-details.sheet-hideleft GP:
        .sheet-ui.sheet-skill-money-details.sheet-hideleft
          %input{type: 'text', name: "attr_goldPieces"}
        .sheet-label.sheet-skill-money-details.sheet-hideleft SP:
        .sheet-ui.sheet-skill-money-details.sheet-hideleft
          %input{type: 'text', name: "attr_silverPieces"}
        .sheet-label.sheet-skill-money-details.sheet-hideleft CP:
        .sheet-ui.sheet-skill-money-details.sheet-hideleft
          %input{type: 'text', name: "attr_copperPieces"}
        .sheet-label.sheet-skill-money-details.sheet-hideleft Fate:
        .sheet-ui.sheet-skill-money-details.sheet-hideleft
          %input{type: 'text', name: "attr_fatePoints"}

    -# NOTES
    .sheet-notes
      .sheet-label.sheet-table-header.sheet-notes-header NOTES
      - 25.times do |i|
        .sheet-ui.sheet-notes-miscline-left
          %input{type: 'text', name: "attr_notesMisclineLeft#{i}"}
      - 25.times do |i|
        .sheet-ui.sheet-notes-miscline-right
          %input{type: 'text', name: "attr_notesMisclineRight#{i}"}

%script{type: 'text/worker'}
  :plain
    /*  ======================================================
                BEGIN MULTIVERSAL SHEET WORKER GENERATOR
        ======================================================
        Use this script to build sheet workers automatically.
        Place this section in your script block, preferably at the end.
        Fill the two data objects, multistats and multifunctions, with your details.
        VERSION 1.
        READMORE: https://app.roll20.net/forum/permalink/7664925/
        ======================================================*/

    const multistats = {};

    // Attribute bonus summing
    ['str', 'con', 'dex', 'int', 'wis', 'cha'].forEach(x => {
      multistats[`${x}mod`] = {rule: 'dnd_stat_bonus', attributes: [x]};
      multistats[`${x}tempmod`] = {rule: 'dnd_tmpstat_bonus', attributes: [x, `${x}temp`]};
    });

    // STR mod fillers
    ['grappleStatBonus', 'climbStatMod', 'jumpStatMod', 'swimStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['StrTempMod']};
    });

    // DEX mod fillers
    ['acdex', 'rangeStatBonus', 'saveRefStat', 'balanceStatMod', 'escapeartistStatMod', 'hideStatMod', 'moveSilentlyStatMod',
     'openLockStatMod', 'rideStatMod', 'sleightOfHandStatMod', 'tumbleStatMod', 'useRopeStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['DexTempMod']};
    });

    // CON mod fillers
    ['saveFortStat', 'concentrationStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['ConTempMod']};
    });

    // INT mod fillers
    ['appraiseStatMod', 'craftFillIn1StatMod', 'craftFillIn2StatMod', 'craftFillIn3StatMod', 'decipherScriptStatMod', 'disableDeviceStatMod', 'forgeryStatMod', 'knowledgeFillIn1StatMod', 'knowledgeFillIn2StatMod', 'knowledgeFillIn3StatMod', 'knowledgeFillIn4StatMod', 'knowledgeFillIn5StatMod', 'psicraftStatMod', 'searchStatMod', 'speakLanguageStatMod', 'spellcraftStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['IntTempMod']};
    });

    // WIS mod fillers
    ['autohypnosisStatMod', 'healStatMod', 'listenStatMod', 'professionFillIn1StatMod', 'professionFillIn2StatMod', 'survivalStatMod', 'senseMotiveStatMod', 'spotStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['WisTempMod']};
    });

    // CHA mod fillers
    ['bluffStatMod', 'diplomacyStatMod', 'disguiseStatMod', 'gatherInfoStatMod', 'handleAnimalStatMod', 'intimidateStatMod', 'performFillIn1StatMod', 'performFillIn2StatMod', 'performFillIn3StatMod', 'usePsionicDeviceStatMod', 'useMagicDeviceStatMod'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['ChaTempMod']};
    });

    // BAB filler
    ['meleeBase', 'rangeBase', 'grappleBase'].forEach(x => {
      multistats[`${x}`] = {rule: 'fill', attributes: ['baseAttackBonus']};
    })

    // Weight Summing
    const backpack = _.map([...Array(28).keys()], function(n) {return 'backpackWt' + n})
    const worn     = _.map([...Array(28).keys()], function(n) {return 'wornWt' + n})
    const magic    = _.map([...Array(28).keys()], function(n) {return 'magicItemWt' + n})
    const armor    = _.map([...Array(5).keys()], function(n) {return 'armorWt' + n})
    const weapon   = _.map([...Array(7).keys()], function(n) {return 'weaponWt' + n})
    const allwt    = _.union(backpack, worn, magic, armor, weapon)
    multistats['totalweight'] = {rule: 'sum', attributes: allwt};

    // Armor & Save Summing
    multistats['acTotal'] = {rule: 'sum', attributes: ['acBase', 'acArmor', 'acShield', 'acDex', 'acSize', 'acNat', 'acDeflect', 'acMisc']};
    ['Fort', 'Will', 'Ref'].forEach(x => {
      multistats[`save${x}total`] = {rule: 'sum', attributes: [`save${x}Base`, `save${x}Stat`, `save${x}Magic`, `save${x}Misc`]};
    })

    // Attack Bonus Summing
    const attack_types = ['grapple', 'melee', 'range']
    attack_types.forEach(x => {
      multistats[`${x}total`] = {rule: 'sum', attributes: [`${x}Base`, `${x}StatBonus`, `${x}Size`, `${x}Misc`]};
    })

    // Size based fillers
    multistats['meleeSize'] = {rule: 'size_to_attack_ac', attributes: [size]};
    multistats['rangeSize'] = {rule: 'size_to_attack_ac', attributes: [size]};
    multistats['rangeSize'] = {rule: 'size_to_attack_ac', attributes: [size]};
    multistats['acSize']    = {rule: 'size_to_special_attack', attributes: [size]};

    // Weight Calculations
    multistats['weightHeavy'] = {rule: 'carry_weight', attributes: [str, strtemp, size]};

    // TODO: Touch/FF AC filler
    // TODO: Skill Summing (remember size bonus to hide)

    const multifunctions = {
        fill: (x) => x,  // just return a value to fill another cell
        sum: (x) => x.reduce((total, add) => total + add),  // add up any number of attributes
        dnd_stat_bonus: (x) => Math.floor(x[0]/2 -5),
        dnd_tmpstat_bonus: (x) => Math.floor((x[0]+x[1])/2 -5),
        carry_capacity: (x) => {
          const size_multiplier = {fine: 0.125, diminutive: 0.25, tiny: 0.5, small: 0.75, medium: 1, large: 2, huge: 4, gargantuan: 8, colossal: 16}
          const str_lookup = {0: 0, 1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60, 7: 70, 8: 80, 9: 90, 10: 100, 11: 115, 12: 130, 13: 150, 14: 175, 15: 200, 16: 230, 17: 260, 18: 300, 19: 350, 20: 400, 21: 460, 22: 520, 23: 600, 24: 700, 25: 800, 26: 920, 27: 1040, 28: 1200, 29: 1400, 30: 1600, 31: 1840, 32: 2080, 33: 2400, 34: 2800, 35: 3200, 36: 3680, 37: 4160, 38: 4800, 39: 5600, 40: 6400, 41: 7360, 42: 8320, 43: 9600}
          let str = Math.min(43, Math.max(0, x[0] + x[1]))
          size_multiplier[x[2]] * (str_lookup[str])
        },
        size_to_attack_ac: (x) => {
          const bonus = {fine: 8, diminutive: 4, tiny: 2, small: 1, medium: 0, large: -1, huge: -2, gargantuan: -4, colossal: -8}
          bonus[x.toLowerCase()]
        },
        size_to_special_attack: (x) => {
          const bonus = {fine: -16, diminutive: -12, tiny: -8, small: -4, medium: 0, large: 4, huge: 8, gargantuan: 12, colossal: 16}
          bonus[x.toLowerCase()]
        },
        size_to_hide_mod: (x) => {
          const bonus = {fine: 16, diminutive: 12, tiny: 8, small: 4, medium: 0, large: -4, huge: -8, gargantuan: -12, colossal: -16}
          bonus[x.toLowerCase()]
        },
    };

    // ======================================================*/
    //           DO NOT EDIT BELOW THIS LINE                 //
    // ======================================================*/
    const mvlog = (title, text, color = 'green', style='font-size:12px; font-weight:normal;', headerstyle = 'font-size:13px; font-weight:bold;') => {
        let titleStyle = `color:${color}; ${headerstyle} text-decoration:underline;`;
        let textStyle = `color:${color}; ${style}`;
        const output = `%c${title}:%c ${text}`;
        console.log(output,titleStyle,textStyle);
    };
    // can use $ placeholder in attribute names. This converts '$_stat' to 'repeating_section_stat'
    const rep = '$'; //placeholder for repeating_section_
    const makeRepeatingName = (attribute, section) => attribute.startsWith(rep) ? attribute.replace(rep, `repeating_${section}_`) : attribute;
    const makeRepeatingAttributes = (attributes, section) => attributes.map(a => makeRepeatingName(a, section));
    const makeRepeatingID = (a, section, id) => a.replace(`repeating_${section}_`,`repeating_${section}_${id}_`);
    // given array of attributes, find if any have repeating_ and return the section name
    // section name will be 2nd element of name split on "_"
    const findSection = (arr) => {
        const s = arr.find(a => a.includes('repeating_'));
        const section = (s ? s.split('_')[1] : null);
        return section;
    };

    // check if attribute is one where a repeating section attribute depends on attributes both inside and outside the repeating section
    const isMixed = (attributes, destination) => {
        const some = someRepeating(attributes);
        const all = allRepeating(attributes);
        const repeatingdestination = destination.startsWith('repeating_');
        return (some && !all && repeatingdestination);
    };
    const allRepeating = attributes => attributes.every(r => r.startsWith('repeating_'));
    const someRepeating = attributes => attributes.some(r => r.startsWith('repeating_'));

    const defaultDataType = 'array'; // might change this to object
    const getData = (values, data = 'a', isnumbers = 0) => {
        // only a is functional right now, so this function is redundant.
        switch(data.charAt(0).toLowerCase()) {
            case 'o': return values;
            case 'a': return Object.values(values).map(i => 1 === isnumbers ? parseInt(i) ||0 : (0 === isnumbers ? +i || 0 : i));
            case 'v': return Object.values(values)[0];
        }
    };

    const processMax = (destination, result, max) => {
        const settings = {};
        if(max === 'current' || max === 'both') settings[destination] = result;
        if(max === 'max' || max === 'both') settings[`${destination}_max`] = result;
        return settings;
    };

    const isFunction = value => value && (Object.prototype.toString.call(value) === '[object Function]' || 'function' === typeof value || value instanceof Function);

    const processFunction = (destination, values, section) => {
        const rule = multistats[destination].rule;
        const func = isFunction(rule) ? rule:  multifunctions[rule]; // need to test if this works for arrow functions
        const data = multistats[destination].data || defaultDataType;
        const v = getData(values, data);
        const modifier = multistats[destination].modifier || null;
        const result = func(v, modifier);
        mvlog(`${makeRepeatingName(destination,section).toUpperCase()} MULTIFUNCTION`, `RULE: ${rule}; VALUES: ${JSON.stringify(values)}; RESULT: ${result}`);
        return result;
    };

    Object.keys(multistats).forEach(destination => {
        // get the section name if it exists. It is needed for mixed workers
        const attributes_base = multistats[destination].attributes;
        const section = multistats[destination].section || findSection(attributes_base) || null;
        const attributes = makeRepeatingAttributes(attributes_base, section);
        const realdestination = makeRepeatingName(destination, section); // needed in case of $ in destination
        mvlog(`MULTIVERSAL- ${realdestination}`,`${attributes.join(', ')}`,'green');
        if (isMixed(attributes, realdestination)) {
            const changes = attributes.reduce((change, step) => `${change} change:${step.replace('repeating_' + section + '_','repeating_' +section + ':')}`,
                `remove:repeating_${section} sheet:opened`);
            on(changes.toLowerCase(), function (event) {
                const trigger = event.sourceAttribute || '';
                const triggerRow = (trigger && trigger.includes('_') && trigger.length >2) ? trigger.split('_')[2] : '';
                // if triggerRow, only update initial row
                getSectionIDs(`repeating_${section}`, function (ids) {
                    const sectionAtts = attributes.filter(f => f.startsWith(`repeating_${section}`));
                    const fixedAtts = attributes.filter(f => !f.startsWith(`repeating_${section}`));
                    if (triggerRow) ids = [triggerRow];
                    const fieldNames = ids.reduce( (m,id) => [...m, ...(sectionAtts.map(field => makeRepeatingID(field,section,id) ))],[]);
                    getAttrs([...fieldNames,...fixedAtts], function (values) {
                        let settings = {};
                        const max = multistats[destination].max || 'current';
                        const fixedValues = fixedAtts.reduce((obj, a) => {
                            obj[a] = values[a];
                            return obj;
                        }, {});
                        ids.forEach(id => {
                            // first get all relevant attributes for this row of the section
                            const sectionValues = sectionAtts.reduce((obj, a) => {
                                const att = makeRepeatingID(a, section, id);
                                obj[att] = values[att];
                                return obj;}, {});
                            // now apply the formula for this row and add to settings
                            const combinedValues = {...sectionValues,...fixedValues};
                            const result = processFunction(destination,combinedValues, section);
                            const tempDestination = makeRepeatingID(realdestination,section,id);
                            const tempSettings = processMax(tempDestination, result, max);
                            settings = Object.assign({}, settings, tempSettings);
                        });
                        setAttrs(settings);
                    });
                });
            });
        } else {
            const changes = attributes.reduce((change, step) => `${change} change:${step.replace('repeating_' + section + '_','repeating_' +section + ':')}`,
                `${someRepeating([...attributes,realdestination]) ? '' : 'sheet:opened '}${section ? `remove:repeating_${section}` : ''}`);
            on(changes.toLowerCase(), function () {
                getAttrs(attributes, function (values) {
                    const result = processFunction(destination,values, section);
                    const max = multistats[destination].max || 'current';
                    const settings = processMax(realdestination, result, max);
                    setAttrs(settings);
                });
            });
        }
    });
